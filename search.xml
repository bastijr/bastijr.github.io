<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>init的角色和任务</title>
      <link href="/2019/08/05/init%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/08/05/init%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在桌面linux中，第一个用户态进程为<code>/sbininit</code>，它会读取<code>/etc/inittab</code>文件，以获取所支持的”运行级“（run-levels）、运行时配置信息（单用户、多用户、网络文件系统等）、需随机启动的进程以及当下用户按下<code>CTRL+Alt+Del</code>组合键时该做出何种反应等信息。</p><p>在android中也是用这样的init程序，但android中的init和linux中的init仅仅是名字相同罢了，它们之前的区别如下表所示：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>配置文件</td><td><code>/etcinittab</code></td><td><code>/init.rc</code>以及它导入的任何文件[通常是<code>init.hardware.rc</code>和<code>init.usb.rc</code>]</td></tr><tr><td>多种配置</td><td>支持：”运行级“的概念（0：系统停机状态； 1：单用户工作状态；2-3： 多用户状态；……）。每个”运行级“都会从<code>/etc/rcrunlevel.d2</code>那里加载脚本</td><td>没有”运行级“的概念，但是通过触发器（trigger）和系统属性提供了配置选项</td></tr><tr><td>watchdog</td><td>支持：用respawn关键字定义过的守护进程会在退出时重启—除非该进程反复崩溃，会在这种情况下，反复崩溃的进程会被挂起几分钟</td><td>支持：服务默认是应该保持活跃的。除非启动它时使用了oneshot参数。服务启动时还可以使用critical参数，这会使系统在该服务无法启动时强制重启</td></tr><tr><td>收容孤儿进程</td><td>支持<code>/sbin/init</code>会调用<code>wait4()</code>系统调用去获取孤儿进程的返回码，避免出现僵尸进程</td><td>支持：<code>/init</code>注册了一个SIGCHLD信号的处理模块，SIGCHLD信号是内核在子进程退出时自动发送的，大多数进程会默默的调用<code>wait(NULL)</code>清理掉已退出的子进程，而不去管他的返回码是什么</td></tr><tr><td>系统属性</td><td>不支持</td><td>支持：<code>/init</code>通过共享一块内存区域的方式，让系统中所有进程都能读取系统属性（通过<code>getopt</code>），并通过一个名为”property_service“的socket让所有权限的进程能够（通过’setopt’）写相关属性</td></tr><tr><td>分配socket</td><td>不支持：linux的init不会向子进程提供socket，这个功能交个inetd的</td><td>支持：<code>/init</code> 会绑定一个UNIX domain socket（从L版开始，是seqpacket socket）提供给子进程，子进程可以通过android_get_control_socker函数获取它</td></tr><tr><td>触发操作</td><td>不支持： linux只支持非常特殊的触发操作，如<code>CTRL+Alt+Del</code>和UPS电源事件，但是不允许任意的触发操作</td><td>支持：<code>/init</code>可以在任何一个系统属性被修改时，执行trigger语句块中的，由任何一个用户预先写好的指令</td></tr><tr><td>处理uevent事件</td><td>不支持：linux依靠的时hotplug守护进程（通常为udevd）</td><td><code>/init</code>也会化身为ueventd，用专门的配置文件来指导其行为</td></tr></tbody></table><p><code>/init</code>是静态链接的可执行文件，在编译时它所依赖的库都已经被合并到这个二进制文件里去了、这样做的目的是为了防止仅仅因为缺少某个库而造成的系统无法正常启动的情况发生。在<code>/init</code>刚被执行时，只有和内核一起打包放在boot分区的RAM disk被mount上来，换句话说，系统中只有<code>/</code>和<code>/sbin</code>。</p><h3 id="系统属性"><a href="#系统属性" class="headerlink" title="系统属性"></a>系统属性</h3><p>android的系统属性提供了一个可以全局访问的配置设置仓库<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="类似于windows注册表的东西，每个属性实际上就是键值对。">[1]</span></a></sup>,它在形式上和MIB数组作为参数调用的<code>sysctl(2)</code>有些类似，只不过是在用户态中，由init实现了。在init的相关源码<code>property_service.c</code>中的代码，会按照下表给出的顺序，从多个文件中加载属性。</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td><code>/default.prop</code>（PROP_PATH_RAMDISK_DEFAULT）</td><td>初始设置。注意。这个文件是initramfs中的一部分，直接到设备的闪存分区上是找不到的</td></tr><tr><td><code>/system/build.prop</code>（PROP_PATH_SYSTEM_BUILD）</td><td>编译android过程中产生的设置</td></tr><tr><td><code>/system/default.prop</code>（PROP_PATH_SYSTEM_DEFAULT）</td><td>通常是厂商添加的设置</td></tr><tr><td><code>/data/local.prop</code>（PROP_PATH_LOCAL_OVERRIDE）</td><td>如果编译init时使用了ALLOW_LOCAL_PROP_OVERRIDE选项，并且<code>ro.debuggable</code>属性被设置为1，那么就会加载这个文件。这使得开发者可以通过<code>/data</code>分区里push一个文件的方式，修改之前的配置</td></tr><tr><td><code>/data/proper/persist.*</code>（PERSISTENT_PROPERTY_DIR）</td><td>重启后不会丢失的属性（Persistent property），这些属性文件会被加上前缀persist。它们会被分别存放在<code>/data/proper</code>目录中的各个文件里，躲过重启。只要<code>/init.rc</code>脚本中有这条指令，init就会重新加载这些属性</td></tr></tbody></table><p>除了上面中列出的属性文件外，还有另外一个属性文件<code>/factory/factory.prop</code>（PROP_PATH_FACTORY），这个属性文件现在已经不再被支持。</p><p>因为init时系统所有进程的祖先，所以只有它才天生适合实现系统属性的初始化。在它刚开始初始化的时候，init中的代码会调用<code>property_init</code>去安装系统属性。这个函数最终会调用<code>map_prop_area()</code>函数，并打开PROP_FILENAME（这个宏定义指的是<code>/dev/__properties__</code>），然后在关闭这个文件的描述符之前，用<code>mmap(2)</code>系统调用以”读/写“权限把这个文件的内容map到内存里。之后，init又会再次打开这个文件，不过这词用的是O_READONLY，然后再unlink掉它。</p><p>属性文件的只读文件描述符被设为可以被子进程继承。这使得系统中任何一个进程都可以方便的通过<code>mmap(2)</code>映射这个文件描述符的方式访问到系统的属性—尽管只能读。这是一个很巧妙的方法，它让所有可以访问属性的用户共享了这块被称为<code>__system_property_area</code>的物理内存<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="`/dev/__properties__`文件被mmap到内存中后，map了该文件内容的内存区域的起始位置就会被记录到全局变量`__system_property_area`上。">[2]</span></a></sup>（它的大小是用宏定义<code>PA_SIZE</code>来表示，这个宏定义的默认值为128KB）。除了init进程，别的进程都无法对<code>__system_property_area</code>进行写操作。下面为华为荣耀平板（JDN-W09）的输出结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>init 的内存区域</span><br><span class="line">root@hwjdn:/proc # grep properties /proc/1/maps</span><br><span class="line">7fa045b000-7fa0483000 rw-s 00000000 00:0c 10356                          /dev/__properties__</span><br><span class="line"><span class="meta">#</span>其它进程 的内存区域</span><br><span class="line">root@hwjdn:/proc # grep properties /proc/$$/maps</span><br><span class="line">7fa7991000-7fa79b9000 r--s 00000000 00:0c 10356                          /dev/__properties__</span><br><span class="line">7fa7baf000-7fa7bd7000 r--s 00000000 00:0c 10356                          /dev/__properties__</span><br></pre></td></tr></table></figure><p><code>__system_property_area</code>这块内存区域的开头部分是一个很短的头部，其中记录了一个序列号（内部版本号）、一个签名文件（<code>0x504f5250</code>，也是<code>PROP</code>）以及一个版本号。紧接着这个头部的时112字节的被存储在一种混杂使用了单词查找树[Trie树或字典树]和二叉树的数据结构中。这个数据结构在Bionic的<code>system_properties.cpp</code>文件中有相当明晰的文档，如下面代码所示<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="原文中说的是c文件，但实际上下面这段代码是在cpp文件中：[code](https://android.googlesource.com/platform/bionic/+/5a3ab3422d8b8f500eda70edf7b0fff83656603a/libc/bionic/system_properties.cpp)。">[3]</span></a></sup>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Properties are stored in a hybrid trie/binary tree structure.</span></span><br><span class="line"><span class="comment"> * Each property's name is delimited at '.' characters, and the tokens are put</span></span><br><span class="line"><span class="comment"> * into a trie structure.  Siblings at each level of the trie are stored in a</span></span><br><span class="line"><span class="comment"> * binary tree.  For instance, "ro.secure"="1" could be stored as follows:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * +-----+   children    +----+   children    +--------+</span></span><br><span class="line"><span class="comment"> * |     |--------------&gt;| ro |--------------&gt;| secure |</span></span><br><span class="line"><span class="comment"> * +-----+               +----+               +--------+</span></span><br><span class="line"><span class="comment"> *                       /    \                /   |</span></span><br><span class="line"><span class="comment"> *                 left /      \ right   left /    |  prop   +===========+</span></span><br><span class="line"><span class="comment"> *                     v        v            v     +--------&gt;| ro.secure |</span></span><br><span class="line"><span class="comment"> *                  +-----+   +-----+     +-----+            +-----------+</span></span><br><span class="line"><span class="comment"> *                  | net |   | sys |     | com |            |     1     |</span></span><br><span class="line"><span class="comment"> *                  +-----+   +-----+     +-----+            +===========+</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="property-service"><a href="#property-service" class="headerlink" title="property_service"></a>property_service</h4><p>为了能提供写（系统属性）请求的服务，init专门打开了一个专用的UNIX domain socket—<code>/dev/socket/property_service</code>。只要能连上这个socket，任何人都可以对它进行写操作（0666）。这些（通过<code>/dev/socket/property_service</code>这个socket）写入的命令会被直接送给init，init首先回去检查调用者是不是有设置相关属性的权限（这些权限信息在<code>property_perms</code>数组中）。权限的检查方式为判断uid和gid，判断调用者的uid和gid（<code>/dev/socket/property_service</code>这个socket的调用者证书中包含相关信息）是否和数组中的定义相符。如果系统包含有SELinux增强，属性的namespace还会改用安全上下文（security context，定义带<code>/property_contetxts</code>中）提供更好的保护。</p><h4 id="特殊的namespace前缀"><a href="#特殊的namespace前缀" class="headerlink" title="特殊的namespace前缀"></a>特殊的namespace前缀</h4><p>init能够识别出一些特定的前缀，这些前缀表示应该如何处理相关属性。</p><ul><li><strong>persist伪前缀</strong>：这个前缀是为了让这些属性在系统重启后依然生效，这些重启后不会丢失的属性保存在<code>/data/property/</code>目录里的各个文件中，这些文件的拥有者必须要是<code>root:root</code>,且不是链接。</li><li><strong>ro伪前缀</strong>：这个是用来标记只读属性的。不管是操作者还是拥有者，它都能设置且只能设置一次。通常，这些设置在场上提供build文件时就已经设置好了。</li><li><strong>ctl前缀</strong>：这个前缀为了方便控制init中提供的各种服务而设立的，通过设置相关服务的<code>ctl.start</code>或者<code>ctl.stop</code>属性的值，就能很便捷的控制相关的服务。（toolbox中的start和stop工具实际上就是利用这个带ctl前缀的属性来控制zygote、surfacefliger和netd的）。在<code>control_perms</code>数组中记录一个不连续的ACL（Access Control List，访问控制列表），通过uid和gid来指定谁有启动和停止的权利。从Lollipop版本之后，SELinux接管了ACL的访问控制职能。</li></ul><h4 id="属性的访问方法"><a href="#属性的访问方法" class="headerlink" title="属性的访问方法"></a>属性的访问方法</h4><p>在toolbox里提供了两个属性访问的命令行工具<code>getprop</code>和<code>setprop</code>，另外还有属性监听工具<code>watchprops</code>。属性访问的原生api都在<code>system/core/include/cutils/property.h</code>文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定属性key和value，如果key的值不存在的话，也可以用参数default_value给一个默认值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">property_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">char</span>* value, <span class="keyword">const</span> <span class="keyword">char</span>* default_value)</span></span>;</span><br><span class="line"><span class="comment">// 设定指定属性key的值，这个接口把key和value串在一起，用property_service这个socket发送给init</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">property_set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>;</span><br><span class="line"><span class="comment">// 用一个回调函数propfn来一一处理各个属性。只要有一个属性，这个回调函数就会被调用一次。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">property_list</span><span class="params">(<span class="keyword">void</span> (*propfn)(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">void</span> *cookie), <span class="keyword">void</span> *cookie)</span></span>;</span><br></pre></td></tr></table></figure><p><code>sys/_system_properties.h</code>文件中还定义了一些没有文档支持的接口，其中<code>__system_property_wait_any(unsigned int serial)</code>，它会让调用它的进程进入休眠状态，直到某个属性被修改时被被唤醒，在<code>watchprops</code>工具中就用了这个函数。在框架中，使用接口<code>android.os.SystemProperties</code>类来访问系统属性。</p><h3 id="rc文件"><a href="#rc文件" class="headerlink" title=".rc文件"></a>.rc文件</h3><p>init的主要操作是加载它的配置文件，并依照配置文件执行相应的命令。传统上使用的配置文件有两个：主配置文件<code>/init.rc</code>和与设备相关的配置文件<code>/init.hardware.rc</code>，其中hardware相关的配置应该被替换为从内核参数<code>androidboot.hardware</code>，或从<code>/proc/cpuinfo</code>那里获得的字符串。比如，模拟器中默认使用的这个hardware字段就是<code>goldfish</code>。在实体设备中，系统中直接复制了<code>/init.goldfish.rc</code>文件的情况也不在少数，这可能是因为大部分的设备安装的android系统直接复制了模拟器的文件系统，而忽视了这个细节的缘故。这个设计的主要目的是让所有的android设备都能够共享一个<code>init.rc</code>文件，而与设备紧密相关的特定配置则让厂商写在<code>/init.hardware.rc</code>文件里。但在实际应用中，有时为了省事，也会把一些硬件相关的配置直接加在了<code>/init.rc</code>中。</p><h4 id="trigger、action和service"><a href="#trigger、action和service" class="headerlink" title="trigger、action和service"></a>trigger、action和service</h4><p>.rc文件是由trigger语句块和service语句块构成的。trigger语句块中的命令，会在触发条件被满足时执行；而service语句块中定义的时各个守护进程，init会根据命令启动相关守护进程，也可以根据相关参数修改服务状态。service语句块由关键字service开头，后面跟着服务名及命令行。trigger语句块由关键字<strong>on</strong>定义，后面跟着一个参数（这个参数既可以是预先规定的各个启动阶段boot stage的名称，也可以是一个property关键字，后面跟冒号加”属性名称=属性值“这样的表达式），如果条件被满足，相应的属性值会改成指定的值。在执行指定action或command时，init会分别把属性<code>init.action</code>或<code>init.command</code>的值设置为当前正在执行的动作的名称。预先规定的启动阶段见下表（并不一定每个启动阶段都必须使用）：</p><table><thead><tr><th>启动阶段</th><th>内容</th></tr></thead><tbody><tr><td>early-init</td><td>初始化的第一个阶段，用于设置SELinux和ODM</td></tr><tr><td>init</td><td>创建文件系统，mount点以及写内核变量</td></tr><tr><td>early-fs</td><td>文件系统准备被mount前需要完成的工作</td></tr><tr><td>fs</td><td>专门用于加载各个分区</td></tr><tr><td>post-fs</td><td>在各个文件系统（<code>/data</code>分区除外）mount完毕后需要执行的命令</td></tr><tr><td>post-fs-data</td><td>解密<code>/data</code>分区（可选），并mount之</td></tr><tr><td>early-boot</td><td>在属性服务（property service）初始化之后，启动剩余内容之前需完成的作业</td></tr><tr><td>boot</td><td>正常启动命令</td></tr><tr><td>charger</td><td>当手机处于充电模式时需要执行的命令</td></tr></tbody></table><h4 id="init-rc的语法和命令集"><a href="#init-rc的语法和命令集" class="headerlink" title="init.rc的语法和命令集"></a>init.rc的语法和命令集</h4><p><code>init.rc</code>及其导入的文件都有非常好的注释。<code>init_parser.c</code>中的代码在解析rc文件时，能否识别出<code>COMMAND</code>（值在<em>on</em>关键字开头的语句块中有效）和<code>OPTION</code>（只在<em>service</em>关键字开头的语句块中有效）。下表列出了init所支持的各个<code>COMMAND</code>关键字（<code>keywords.h</code>）。</p><table><thead><tr><th>命令</th><th>语法</th></tr></thead><tbody><tr><td>bootchart_init</td><td>启用启动时的信任链验证</td></tr><tr><td>chdir <em>dir</em></td><td>等价于cd命令</td></tr><tr><td>chmod <em>actal_perms file</em></td><td>修改制定文件的权限</td></tr><tr><td>chown <em>user group file</em></td><td>等价于chown <em>user:group file</em>命令</td></tr><tr><td>Chroot <em>dir</em></td><td>等价于chroot</td></tr><tr><td>class_reset service_calss</td><td>停止与service_class相关的所有服务</td></tr><tr><td>class_[start|stop] <em>class</em></td><td>启动或者定制class参数制定的service_class相关的所有服务</td></tr><tr><td>copy <em>src dst</em></td><td>类似于cp命令</td></tr><tr><td>domainname domainname</td><td>把制定的域名写入<code>/prco/sys/kernel/domainname</code>伪文件中</td></tr><tr><td>exec <em>command</em></td><td>不再支持</td></tr><tr><td>enable <em>service</em></td><td>启动一个被disable的服务</td></tr><tr><td>export <em>variable value</em></td><td>全局环境中，设置环境变量<em>variable</em>的值，该命令的执行结果会影响所用到的所有进程</td></tr><tr><td>hostname <em>hostname</em></td><td>把主机名写入<code>/proc/sys/kernel/hostname</code>伪文件中</td></tr><tr><td>ifup <em>interface</em></td><td>激活指定的网卡</td></tr><tr><td>insmod <em>ko</em></td><td>加载一个内核模块</td></tr><tr><td>import <em>filename.rc</em></td><td>导入另一个rc文件</td></tr><tr><td>load_all_props</td><td>加载build,default,factory文件中规定的属性</td></tr><tr><td>load_persist_props</td><td>加载<code>/data/propert</code>目录中的各个文件中的属性</td></tr><tr><td>loglevel <em>level</em></td><td>设置内核的日志级别</td></tr><tr><td>mkdir <em>dir</em></td><td>创建一个目录</td></tr><tr><td>mount <em>fstype fs point</em></td><td>把指定分区类型（<em>fstype</em>）的分区（<em>fs</em>）mount到指定的mount点（<em>point</em>）上去</td></tr><tr><td>mount_all</td><td>mount所有在<code>vold</code>守护进程使用的<code>/fstab.hardware</code>中规定的文件系统，这会使init <code>fork()</code>出一个子进程，并在这个子进程中用fs_mgr执行mount操作。init同时也能检测出所有加密的文件系统</td></tr><tr><td>powerctl shoutdown/reboot</td><td>对shutdown和reboot的封装</td></tr><tr><td>[re]start <em>service_name</em></td><td>启动/重启服务名与参数<em>service_name</em>相同的service语句块中规定的服务</td></tr><tr><td>restorecon[_recursive] path</td><td>用path参数指定的文件重新加载SELinux上下文</td></tr><tr><td>rm[dir] <em>filename</em></td><td>删除文件或目录</td></tr><tr><td>setcon SEcontext</td><td>设置或改变SELinux的上下文，init使用的上下文是<code>u:r:init:s0</code></td></tr><tr><td>setenforce [0|1]</td><td>强制启动或者关闭SELinux</td></tr><tr><td>setkey <em>table index value</em></td><td>设置键盘映射表的内容</td></tr><tr><td>setprop <em>key value</em></td><td>设置指定的系统属性</td></tr><tr><td>setsebool <em>name value</em></td><td>设置某个与SELinux相关的bool型属性</td></tr><tr><td>setlimit <em>category min max</em></td><td>使用<code>setlimit(2)</code>系统调用，设置进程可用资源的上下限</td></tr><tr><td>stop <em>service_name</em></td><td>停止服务名与参数<em>service_name</em>相同的service语句块中规定的服务</td></tr><tr><td>swapon all</td><td>激活所有fstab中的swap分区</td></tr><tr><td>symlink <em>target src</em></td><td>创建一个符号链接</td></tr><tr><td>sysclktz <em>tzoffset</em></td><td>设置系统时区</td></tr><tr><td>verity_load_state</td><td>加载DM-verity（分区加密）状态</td></tr><tr><td>verity_update_state <em>mount</em></td><td>更新DM-verity状态，并设置系统属性<code>partition.mount.verified</code></td></tr><tr><td>wait <em>file timeout</em></td><td>等待文件<em>file<em>创建完，等待最大时间不超过</em>timeout</em></td></tr><tr><td>write <em>file value</em></td><td>把<em>value</em>写入到文件<em>file</em>中去</td></tr></tbody></table><p><code>COMMAND</code>关键字指令会被用在各个启动阶段中，去执行在系统启动时所需要的操作，如设置目录结构、调整权限、通过<code>/proc</code>或<code>/sys</code>设置相关的内核参数。启动阶段所要执行的指令处理完成后，就需要处理服务相关的指令，按照规定，service语句块中使用的命令必须是用<code>OPTION</code>关键字指令，这些指令确定了该如何运行服务，以及相关服务退出/崩溃时需要进行的操作。下表列出了各个可用的<code>OPTION</code>关键字。</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>capability</td><td>支持Linux的<code>capability(7)</code></td></tr><tr><td>class</td><td>把服务加入某个服务组，可以用class_[start|stop|reset]命令同时操作组内的服务</td></tr><tr><td>console</td><td>把该服务定义为一个console服务，<code>stdin/stdout/stderr</code>会被link到<code>/dev/console</code>上</td></tr><tr><td>critical</td><td>把该服务定义为一个关键服务，关键服务崩溃后会自动重启。如果在<code>CRITICAL_CRASH_WINDOW(240)</code>秒之内，它的崩溃次数超过了<code>CRITICAL_CRASH_THRESHOLD(4)</code>次，系统将会进入recovery模式</td></tr><tr><td>disable</td><td>表示该服务不需要启动，但可以手动启动</td></tr><tr><td>group</td><td>规定该服务以指定的gid启动。init会调用<code>setgid(2)</code>来完成这一操作</td></tr><tr><td>ioprio</td><td>指定该服务的I/O优先级，init会调用<code>ioprio_set</code>来完成</td></tr><tr><td>keycodes</td><td>指定触发该服务的组合键</td></tr><tr><td>oneshot</td><td>让init启动该服务后就不在管它了（忽略<code>SIGCHLD</code>信号）</td></tr><tr><td>onrestart</td><td>列出该服务重启时要执行的命令，通常用来重启其它依赖服务</td></tr><tr><td>seclabel</td><td>指定应用在该服务上的SELinux标签</td></tr><tr><td>setenv</td><td>该服务被<code>fork()</code>出来并被<code>exec()</code>之前，先给它设置一个环境变量。这个变量只对该服务有效</td></tr><tr><td>socket</td><td>告诉init打开一个UNIX Domain socket，并让该服务集成这个socket，这样做的目的是解决服务的<code>stdin/stdout</code>的设置问题</td></tr><tr><td>user</td><td>指定该服务以指定的uid运行，init将调用<code>setuid(2)</code>完成这个任务</td></tr><tr><td>writepid</td><td>把子进程的PID写到指定的文件中去，用于设置cgroup资源控制</td></tr></tbody></table><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>android中的init还是用pid=1进程的传统方式启动服务的，即它<code>fork()</code>出服务子进程，然后调用<code>setuid(2)</code>/<code>setpid(2)</code>设置服务子进程的权限，并设置该服务子进程用来捕获输入的socket及配置环境变量、I/O优先级（在服务块语句中使用ioprio关键字）和SELinux上下文。对于使用console关键字定义的服务，init会把<code>/dev/console</code>连到它的<code>stdin/stdout/stderr</code>上，而对其他服务，它会把stdio给干掉。只有当这些操作都执行完毕后，init才会去执行服务本身的二进制可执行文件。</p><p>在服务启动之后，init会维持一个指向该服务的父链接（parental link），一旦服务停止运行或者崩溃，init就会收到一个<code>SIGCHLD</code>信号，并注意这一事件，然后重启该服务。onrestart关键字会使init在各个指定的服务之间建立起关联，当特定的服务需要重启时，init会去运行这个使用了onrestart关键字的service语句块中的命令，或者重启与该服务有依赖关系的服务。对于每一个服务，init还会维持一个反映了该服务当前运行状态的属性<code>init.svc.service</code>。</p><h4 id="组合键"><a href="#组合键" class="headerlink" title="组合键"></a>组合键</h4><p>init能够在用户按下某个组合键（keychords）是启动某些服务。每个键都有指定的ID（来自Linux的evdev输入机制）。写在keycodes关键字后面的，是android键盘布局文件（<code>/system/usr/keylayout</code>）中规定的键位代码，而不是android框架规定和使用的键位代码（<code>frameworks/native/include/android/keycodes.h</code>）。</p><p>要支持组合键，<code>/dev/keychord</code>文件是必须存在的。这个文件是由一个keychord内核驱动导出的设备节点。</p><h4 id="mount文件系统"><a href="#mount文件系统" class="headerlink" title="mount文件系统"></a>mount文件系统</h4><p>尽管有vold，但init仍然需要执行一些mount操作。在init刚刚启动时，只有root文件系统被mount上来，此时<code>/system</code>和<code>/data</code>都没有被mount，且vold等守护进程都在<code>/system</code>中，所以需要init进程至少把<code>/system</code>mount上来。</p><p>init能够认出<code>/init.rc</code>中的mount_all指令，并执行mount所有默认文件系统（<code>/fstab.hardware</code>文件中）的操作。执行mount操作的代码位于fs_mgr中，无论<code>/init</code>还是vold都会使用它。当<code>/init</code>执行mount操作时，它首先会<code>fork()</code>一个子进程执行相关操作，这是为了避免在执行mount时出现问题而影响自己的启动活动。</p><p>被<code>fork()</code>出来的子进程会去执行mount操作，如果有需要，还会对文件系统进行fsck操作。fs_mgr中规定了对各种不同的文件系统执行fsck操作的程序的所在路径，而且这个fsck操作也是由再次<code>fork()</code>出来的子进程来完成。fs_mgr中会提升日志级别，所以，使用<code>dmesg</code>能够看到fs_mgr输出的各种消息。如果时机足够早的话，是可以看到fs_mgr特有标记的消息。</p><p><code>fork()</code>出来的mount操作子进程会向父进程返回一个返回码。<code>/init</code>会根据这个返回码设置属性<code>vold.decrypt</code>的值，这个属性会被vold读取，并对相应的文件系统进行解密操作。如果没有任何文件系统被加密，init就会执行名为”nonencrypted”的trigger语句块中的指令。</p><h3 id="init总结"><a href="#init总结" class="headerlink" title="init总结"></a>init总结</h3><p>init进程完全遵循建立服务的经典模式：初始化，然后陷入一个循环中，而且永远不想从中退出来。</p><h4 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h4><p>init进程初始化工作由以下步骤组成：</p><ul><li><p>检查自身是否被当成ueventd或watchdogd调用的，如果是，则余下的执行流程会转到相应的守护进程的主循环那里去。</p></li><li><p>创建<code>/dev</code>、<code>/proc</code>、<code>/sys</code>等目录，并mount它们。</p></li><li><p>添加文件<code>/dev/.booting</code>，在启动完毕后，这个文件会被（check_startup）清空。</p></li><li><p>调用<code>open_devnull_stdio()</code>函数完成“守护进程化”操作（把<code>stdin/stdout/stderr</code>链接到<code>/dev/null</code>中）</p></li><li><p>调用<code>klog_init()</code>函数创建<code>/dev/__kmsg__</code>（Major 1， Minor 11），然后立即删除它。</p></li><li><p>调用<code>property_init()</code>函数，在内存创建<code>__system_property_area</code>区域。</p></li><li><p>调用<code>get_hard_name()</code>函数，读取<code>/proc/cpuinfo</code>伪文件中的内容，并提取出“Hardware”一行的内容作为硬件名。以这种方式获取硬件名。</p></li><li><p>调用<code>process_kernel_cmdline()</code>函数，读取<code>/proc/cmdline</code>伪文件中的内容，并把所有<code>androidboot.XXX</code>的属性都复制一份出来，变成r<code>ro.boot.XXX</code>。</p></li><li><p>初始化SELinux。SELinux是放在<code>/dev</code>和<code>/sys</code>里面的。</p></li><li><p>检查设备是否处在“充电模式”。如果设备处于“充电模式”，会使init跳过大部分初始化阶段，并且只加载各个服务中的“charger”类（当前只有“charger”守护进程有这个类）。如果设备没有处于“充电模式”，那么init将会去加载<code>/default.prop</code>，正常执行启动过程。</p></li><li><p>调用<code>init_parse_config_file()</code>函数去解析<code>/init.rc</code>脚本文件。</p></li><li><p>init会把<code>init.rc</code>文件中各个<strong>on</strong>语句块里规定的action（<code>action_for_each_trigger()</code>函数）以及内置的action（<code>queue_builtin_action()</code>函数）添加一个名为<code>action_queue</code>的队列里去。</p></li><li><p>最后，主循环中将逐个执行<code>init.rc</code>中的所有命令</p><p>init将在它的生命周期中的大多数时间里处于休眠状态，偶尔轮询各个文件描述符，并根据宏<code>BOOTCHART</code>有没有被定义，来判断是否需要将日志发送到bootchart，只有在必要的时候init进程才会被唤醒。我们可以通过查看<code>/proc</code>伪文件系统，来了解init进程打开了哪些文件描述符。</p></li></ul><h4 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h4><p>init的主循环相当简洁，一共由三个步骤组成：</p><ul><li><p><code>execute_one_command()</code>：从队列action_queue的头部取出一个action并执行。</p></li><li><p><code>restart_processes()</code>：逐个检查所有已经注册过的服务，并在必要时重启。</p></li><li><p>安装并轮询如下三个socket描述符。</p><ul><li><p><code>property_set_id</code>（<code>/dev/socket/property_service</code>），这个socket是用来让想要设置某个属性的客户端进程，通过它把需要设置的属性的key和value发送给init。init会根据对端进程的证书，来判断这个进程是否有权限进行属性设置。</p></li><li><p><code>keychord_fd</code>（<code>/dev/keychord</code>），它是用来处理上文讨论过的启动服务的组合键。</p></li><li><p><code>signal_recv_fs</code>它是socketpair中的一端，创建它是为了处理因子进程死亡而发来的<code>SIGCHLD</code>信号。当init收到这个信号后，<code>sigchld_hander</code>就会向<code>socketpair(signal_fd)</code>写入数据，这样在这个sockerpair的接受端就能收到这些数据，并导致init去调用<code>wait_for_one_process(0)</code>。这样就能获得已死亡的子进程的返回码，以便去释放该进程残留的资源，防止它成为僵尸进程，然后init会清理这个socketpair中的数据，等待下一个进程挂掉。如果挂掉的进程是critical服务的守护进程的话，init也会重启这个进程。</p></li></ul></li></ul><p>除了上述init监听的三个文件以外，<code>/init</code>是不会再其它任何地方接受输入的。唯一能够修改<code>/init</code>操作行为的方法就是编辑<code>/init.rc</code>，但这个文件位于一个完全隔离的分区，和内核放在一起，除非设备的Boot Loader被解锁，否则无法进行修改。</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">类似于windows注册表的东西，每个属性实际上就是键值对。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><code>/dev/__properties__</code>文件被mmap到内存中后，map了该文件内容的内存区域的起始位置就会被记录到全局变量<code>__system_property_area</code>上。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">原文中说的是c文件，但实际上下面这段代码是在cpp文件中：<a href="https://android.googlesource.com/platform/bionic/+/5a3ab3422d8b8f500eda70edf7b0fff83656603a/libc/bionic/system_properties.cpp" target="_blank" rel="noopener">code</a>。<a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 安卓架构大剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARTS-3</title>
      <link href="/2019/08/04/ARTS-3/"/>
      <url>/2019/08/04/ARTS-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Week-3"><a href="#Week-3" class="headerlink" title="Week 3"></a>Week 3</h1><a id="more"></a><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 1:</p><p>输入: 123<br>输出: 321<br> 示例 2:</p><p>输入: -123<br>输出: -321<br>示例 3:</p><p>输入: 120<br>输出: 21<br>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> flag <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">0</span> || x &lt; <span class="number">-2147483648</span> || x &gt; <span class="number">2147483647</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line">x = -x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ;x != <span class="number">0</span>; &#123;</span><br><span class="line">res = res*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">x = x/<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> flag == <span class="literal">true</span> &#123;</span><br><span class="line">res = -res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res &lt; <span class="number">-2147483648</span> || res &gt; <span class="number">2147483647</span> &#123;</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://elinux.org/Android_Build_System" target="_blank" rel="noopener">Android Build System</a></p><p>安卓构建系统使用一些预设的环境变量和一系列<code>make</code>文件来构建Android系统，并为部署到平台做好准备。Android make文件按照惯例以扩展名‘.mk’结尾，任何特定源目录中的主make文件都被命名为<code>Android.mk</code>。安卓构建系统中只存在唯一一个<code>Makefile</code>，位于整个存储库的源树的顶部。开发者可以自行设置一些环境变量，然后输入<code>make</code>来构建东西。</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://github.com/hakuna-m/wubiuefi/releases" target="_blank" rel="noopener">免分区面U盘安装ubuntu</a></p><p>wubi原来时ubuntu官方提供的从windows安装ubuntu的工具，在12年左右就停止了官方支持。不过在github上有人提供了对新版本支持的非官方wubi（已经支持19.04），如果想保留双系统且又不想分区，可以考虑用这个非官方的wubi软件来安装ubutnu的最新发行版。</p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">AWK 简明教程</a><br>AWK是一款经典的文件二次处理的神器，用好了对工作效率的提高有很大的帮助。</p>]]></content>
      
      
      <categories>
          
          <category> ARTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android系统镜像</title>
      <link href="/2019/07/21/android%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/"/>
      <url>/2019/07/21/android%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>​一般为一套镜像，由厂商提供，刷机时会将各个镜像刷入到各自的分区中。</p><ul><li>Boot Loader：启动时由CPU（或芯片中的应用处理器）执行的代码。这些代码一般用来寻找和加载boot镜像；或者固件升级；或者让系统启动到recovery模式下。多数Boot Loader还会实现简单的usb栈，用来提供给用户控制启动以及升级过程（fastboot）。通常被刷入<code>/aboot</code>分区。</li><li>boot镜像：由内核和ramdisk组成，用来加载系统。ramdisk用作root文件系统，里面包含系统内目录的基本框架，并在<code>/init.rc</code>和相关文件中规定了其它目录的加载方法。通常被刷入<code>/boot</code>分区。</li><li>recovery镜像：由内核和ramdisk（另一个）组成，用来在启动失败或OTA升级时把系统加载到recovery模式下。通常被刷入<code>/recovery</code>分区。</li><li><code>/system</code>镜像：存放的完整的android系统，包含谷歌提供的可执行文件和框架，还有厂商提供的类似定制化的东西。</li><li><code>/data</code>镜像：存放的“默认出厂设置”的数据，它是<code>/system</code>分区中程序正常运行所必需的文件。恢复出厂设置，只需要将这个分区的镜像刷写回去就可以了。<a id="more"></a></li></ul><h3 id="Boot-Loader"><a href="#Boot-Loader" class="headerlink" title="Boot Loader"></a>Boot Loader</h3><p>可以自定义，但是大多数厂商还是选用了LK（Little Kernel）启动加载器。LK并不是android源码树的一部分。LK并不是内核，它只实现了启动功能中最基本的部分（源码 <a href="https://github.com/littlekernel/lk/wiki" target="_blank" rel="noopener">git</a>）。如下：</p><ul><li>基本硬件的支持：在LK的<code>dev/</code>（屏幕帧缓存，按键和被用作usb设备）、<code>platform/</code>（soc驱动）、<code>target/</code>（设备中特定硬件的驱动）等源码树种支持。</li><li>找到并启动内核：找到bootimage，并对它进行解析（内核镜像、ramdisk和设备树），随后运行指定的命令行，把系统的控制权交个内核。这部分代码在<code>app/aboot</code>中。</li><li>基本的UI：在用户中断（<code>adb reboot boot loader</code>）命令时或者在一开始启动时通过特定按键终止启动（这里小米应该是重启时按住音量下键不放）时，aboot能够提供一个简单的界面，用户可以通过物理按键来进行操作。</li><li>支持console：一般在调试母版中才有此功能，在<code>lib/console</code>（被<code>app/shell</code>调用）中提供一个单独的解释器（单独的线程），并且支持用户往里面添加新命令。在<code>lib/gfxconsole</code>中还提供了字体之类的基本图形功能。</li><li>被用作usb目标设备：是Boot Loader可以通过名为fastboot的协议与电脑进行通信。其实现在<code>app/aboot/fastboot.c</code>中，可以按照需求扩展。</li><li>支持闪存分区：支持基本的文件系统，在系统升级或者recovery过程中，能够擦除或者重写一些分区。这部分源码在<code>lib/fs</code>中。</li><li>支持数字签名：能够加载用SSL证书做过数字签名的镜像。在<code>lib/openssl</code>源码中集成了OpenSSL项目的中部分代码。</li></ul><h4 id="bootloader-镜像"><a href="#bootloader-镜像" class="headerlink" title="bootloader 镜像"></a>bootloader 镜像</h4><p>BootLoader能够像其他的系统镜像一样能够更新或者重刷。android源码树中提供了releasetools.py脚本中给出了bootloader镜像文件头的格式。根据文件头格式，用<a href="http://newandroidbook.com/tools/imgtool.html" target="_blank" rel="noopener">imgtool</a>就可以解析出bootloader中所包含的镜像(Nexus 5的BootLoader镜像)：</p><table><thead><tr><th>img</th><th>usage</th><th></th></tr></thead><tbody><tr><td>sbl1</td><td>Secondary Boot Loader，stage 1</td><td>次级Boot Loader</td></tr><tr><td>tz</td><td>TrustZone image</td><td>ARM TrustZone 镜像</td></tr><tr><td>rpm</td><td>Resource Power Mgmt</td><td>资源电源管理引导模块</td></tr><tr><td>aboot</td><td>Application Boot Loader</td><td>应用处理器的BootLoader</td></tr><tr><td>sdi</td><td></td><td></td></tr><tr><td>imgdata</td><td>RLE565 graphics used by boot loader</td><td></td></tr></tbody></table><p>Nexus 5使用的骁龙的处理器，它的aboot镜像包含40字节头：</p><table><thead><tr><th>偏移量</th><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>0x00</td><td>文件签名</td><td>0x00000005（常量）</td></tr><tr><td>0x04</td><td>版本</td><td>版本号</td></tr><tr><td>0x08</td><td>？</td><td>0填充</td></tr><tr><td>0x0c</td><td>镜像加载地址</td><td>把镜像的除头部以外的部分加载到这个字段指定的内存地址上</td></tr><tr><td>0x10</td><td>镜像大小</td><td>aboot的镜像大小</td></tr><tr><td>0x14</td><td>代码大小</td><td>aboot中的代码大小</td></tr><tr><td>0x18</td><td>最后一条指定的地址</td><td>镜像加载基地址+代码大小</td></tr><tr><td>0x1c</td><td>数字签名大小</td><td>数字签名的大小（一般为0x100字节）</td></tr><tr><td>0x20</td><td>被加载到内存中的最后一个字节的地址</td><td>最后一条指令的地址+数字签名的大小</td></tr><tr><td>0x24</td><td>证书链</td><td>证书链的大小（可选）</td></tr></tbody></table><p>紧挨着这个头部的后面就是arm的可启动镜像，这个镜像会被加载到0x0c指定的内存地址中去，镜像的头部存放的是一些arm异常处理向量，也就是一些跳转指令，当发生某些异常（中断、异常或停机）时，处理器就会根据异常处理向量中的指令跳转到指定的代码中去。根据LK中的定义，这个向量中的第一条时reset处理函数。</p><p>下方列出了去掉文件头后提取数字签名的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">od -A d -t x4 aboot | head -5 #od命令解析aboot镜像</span><br><span class="line">dd if=aboot of=aboot.sans.header bs=40 skip=1</span><br><span class="line">dd if=aboot.sans.header of=certs bs=0x3e62c skip=1 #0x3e62c为 镜像大小+数字签名大小</span><br></pre></td></tr></table></figure><h3 id="Boot镜像"><a href="#Boot镜像" class="headerlink" title="Boot镜像"></a>Boot镜像</h3><p>android的Boot镜像包含<strong>内核</strong>和<strong>RAM disk</strong>。它由android源码树中的<em>mkbootimg</em>创建。Boot镜像有一个很小的头部、内核命令行、一个hash以及一个可选的二级启动加载器。所有这组件都是闪存页边界（通常为2KB）对齐的。可以用下面的命令去掉Boot镜像的头部（HTC定义的头部）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=boot of=boot.sans.header bs=0x100 skip=1 #去掉头部</span><br></pre></td></tr></table></figure><p>Boot镜像的格式在bootimg.h的源码中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** +-----------------+ </span></span><br><span class="line"><span class="comment">** | boot header     | 1 page</span></span><br><span class="line"><span class="comment">** +-----------------+</span></span><br><span class="line"><span class="comment">** | kernel          | n pages</span></span><br><span class="line"><span class="comment">** +-----------------+</span></span><br><span class="line"><span class="comment">** | ramdisk         | m pages</span></span><br><span class="line"><span class="comment">** +-----------------+</span></span><br><span class="line"><span class="comment">** | second stage    | o pages</span></span><br><span class="line"><span class="comment">** +-----------------+</span></span><br><span class="line"><span class="comment">** | device tree     | p pages</span></span><br><span class="line"><span class="comment">** +-----------------+</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** n = (kernel_size + page_size - 1) / page_size</span></span><br><span class="line"><span class="comment">** m = (ramdisk_size + page_size - 1) / page_size</span></span><br><span class="line"><span class="comment">** o = (second_size + page_size - 1) / page_size</span></span><br><span class="line"><span class="comment">** p = (dt_size + page_size - 1) / page_size</span></span><br><span class="line"><span class="comment">**</span></span><br><span class="line"><span class="comment">** 0. all entities are page_size aligned in flash</span></span><br><span class="line"><span class="comment">** 1. kernel and ramdisk are required (size != 0)</span></span><br><span class="line"><span class="comment">** 2. second is optional (second_size == 0 -&gt; no second)</span></span><br><span class="line"><span class="comment">** 3. load each element (kernel, ramdisk, second) at</span></span><br><span class="line"><span class="comment">**    the specified physical address (kernel_addr, etc)</span></span><br><span class="line"><span class="comment">** 4. prepare tags at tag_addr.  kernel_args[] is</span></span><br><span class="line"><span class="comment">**    appended to the kernel commandline in the tags.</span></span><br><span class="line"><span class="comment">** 5. r0 = 0, r1 = MACHINE_TYPE, r2 = tags_addr</span></span><br><span class="line"><span class="comment">** 6. if second_size != 0: jump to second_addr</span></span><br><span class="line"><span class="comment">**    else: jump to kernel_addr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">boot_img_hdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> magic[BOOT_MAGIC_SIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> kernel_size;  <span class="comment">/* size in bytes */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> kernel_addr;  <span class="comment">/* physical load addr */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ramdisk_size; <span class="comment">/* size in bytes */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ramdisk_addr; <span class="comment">/* physical load addr */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> second_size;  <span class="comment">/* size in bytes */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> second_addr;  <span class="comment">/* physical load addr */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tags_addr;    <span class="comment">/* physical addr for kernel tags */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> page_size;    <span class="comment">/* flash page size we assume */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dt_size;      <span class="comment">/* device tree in bytes */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused;       <span class="comment">/* future expansion: should be 0 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> name[BOOT_NAME_SIZE]; <span class="comment">/* asciiz product name */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> cmdline[BOOT_ARGS_SIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> id[<span class="number">8</span>]; <span class="comment">/* timestamp / checksum / sha1 / etc */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>linux的内核大多是经过压缩的。内核镜像文件格式（一般为zImage）要求镜像中需要有用来把内核中压缩过的部分解压到内存中的自解压代码。镜像压缩的算法有多种，可以在内核build过程中通过<code>make config</code>决定：</p><table><thead><tr><th>压缩算法的签名</th><th>对应的压缩算法</th><th>说明</th></tr></thead><tbody><tr><td>\x1f\x8b\x08\x00\x00\x00\x00\x00</td><td>GZip</td><td>最常见的压缩算法</td></tr><tr><td>\89LZOx00\x0d\x0a\x1a\x0a</td><td>LZO</td><td>比GZip快，但是压缩率低10%左右。三星用的这种算法</td></tr></tbody></table><p>内核总是最先运行自解压代码，通过搜索压缩算法的签名来确认如何解压。用<code>imgtool</code>可以解压GZip和LZO算法压缩的镜像。</p><p>内核是android系统中与体系结构中最为紧密相关（主板类型、芯片组类型，移动设备中为SoC类型），内核为芯片提供专用的驱动，这些驱动是android源码树的一部分，不同的芯片组对应不同的内核设备树：</p><table><thead><tr><th>项目名称</th><th>芯片组厂商</th><th>设备</th></tr></thead><tbody><tr><td>goldfish</td><td>N/A</td><td>android emulator</td></tr><tr><td>msm</td><td>Qualcomm MSM</td><td>Nexus One, Nexus 4, Nexus 5</td></tr><tr><td>cmap</td><td>TI OMAP</td><td>Galaxy Nexus, Glass</td></tr><tr><td>samsung</td><td>samsung</td><td>Nexus S</td></tr><tr><td>tegra</td><td>NVIDIA</td><td>moto Xoom,Nexus 7&amp;9, Shield</td></tr><tr><td>exynos</td><td>Samsung Exynos</td><td>Nexus 10</td></tr></tbody></table><h4 id="arm中的设备树"><a href="#arm中的设备树" class="headerlink" title="arm中的设备树"></a>arm中的设备树</h4><p>大多数的arm内核需要依赖设备树（device tree）文件来向内核提供硬件设备定义的相关信息。这个文件提供了设备之间的相互关系，内核依据此关系来启动相应的设备。设备树一般加载到内核镜像的尾部，有时也会单独分配一个分区。</p><p>设备树是一个二进制blob文件，通过<em>0xd00dfeed</em>签名来进行识别。具体细节可以参考<a href="https://elinux.org/images/c/cf/Power_ePAPR_APPROVED_v1.1.pdf" target="_blank" rel="noopener">ePAPR specification</a>和<a href="https://bootlin.com/doc/legacy/blob/blob.pdf" target="_blank" rel="noopener">Thomas Petazzoni的关于blob的pdf</a>。</p><h3 id="RAM-disk"><a href="#RAM-disk" class="headerlink" title="RAM disk"></a>RAM disk</h3><p>Boot或者recovery镜像的另一个组件就是<em>initial RAM disk</em>（<em>initrd</em>），在操作系统启动时，它被用作根目录文件系统，它被Boot Loader预加载到RAM中去，不许要其它的驱动。</p><p>initramfs使用来提供内核操作时所需的相关设备的驱动的，由于系统在启动时没有包含任何操作系统，所以initramfs本身是一个文件，而不是一个文件系统镜像。一些重要的驱动文件会包含在这个文件中，内核在启动时就能够在RAM中加载到它们。initramfs中还包含了启动程序<code>/init</code>,内核会把它作为系统中的第一个程序启动起来（pid=1）。</p><h3 id="system与-data镜像"><a href="#system与-data镜像" class="headerlink" title="/system与/data镜像"></a>/system与/data镜像</h3><p>这个两个分区的镜像的存储完全由厂商自己说了算。由于大多数厂商使用的都是fastboot，所以大多数该类镜像都是使用的simg（sparse image）格式。处理这个文件个的工具在asop的<code>/system/core/libsparse</code>的目录下。<br>simg文件的文件头为28个字节，格式如下：</p><table><thead><tr><th>偏移量</th><th>长度</th><th>字段含义</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>文件签名</td></tr><tr><td>4</td><td>4</td><td>版本号（major_version+minor_version）</td></tr><tr><td>8</td><td>2</td><td>头部的大小，总是28</td></tr><tr><td>10</td><td>2</td><td>数据块的大小</td></tr><tr><td>12</td><td>4</td><td>簇的大小，对于ext4来说，这个值一般为0x1000，4KB</td></tr><tr><td>16</td><td>4</td><td>文件系统中簇的个数</td></tr><tr><td>20</td><td>4</td><td>镜像文件中数据块的个数</td></tr><tr><td>24</td><td>4</td><td>校验和（非必须，一般为全0）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 安卓架构大剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> 镜像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>受保护的文件系统和伪文件系统</title>
      <link href="/2019/07/21/%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E4%BC%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/21/%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E4%BC%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章节描述了android系统中常用的两种文件保护系统以及android中用到的linux伪文件系统。</p><h3 id="OBB：Opaque-Binary-Blobs"><a href="#OBB：Opaque-Binary-Blobs" class="headerlink" title="OBB：Opaque Binary Blobs"></a>OBB：Opaque Binary Blobs</h3><p>谷歌商店里，会把apk限制在50MB以内，如果超过这个大小，则需要用户以OBB文件的形式提供最大不超过2GB的额外数据文件。</p><p>Opaque代表不透明，这表示OBB文件的数据格式由开发者决定（尽管在许多时候，它就是个vfat文件系统镜像），有volume守护进程来mount它。vold随后会调用linux内核中的device mapper。用loop（将文件系统中的镜像挂载为一个块设备，这里的loop是指循环挂载）参数进行mount操作。device mapper支持tow-fish算法，在发起OBB mount请求时，把秘钥传递给它。随后应用程序调用android.os.StorageManager中的mountOBB方法，来用指定的秘钥来mount OBB文件。这一过程如图所示(p75,图2-1)。</p><p>OBB虽然不透明，但是OBB文件中仍然有一些类型的元数据，这些数据能够被解析。解析OBB的代码位于<code>/system/lib/libabdroidfw.so</code>中。OBB的文件元数据位于文件尾部，解析该元数据需要倒着解析。文件元数据中各个字段的含义如图(p76,图2-2)。</p><p>android源码树中有一个obbtool工具，这个工具是一个脚本，用来创建OBB文件。该脚本的处理流程如下：</p><ol><li>这个脚本首先会创建一个空的vfat镜像，然后使用device mapper以loop参数mount它。</li><li>mount之后，往里面添加文件。</li><li>umount之后，会把数据再次写入vfat镜像。</li></ol><p>除此之外，sdk中也提供了一个能创建和维护obb文件的jobb工具；再android开发框架中也有一个ObbScanner类，它能够获取obb文件中的基本元数据。</p><h3 id="Asec（android-secure-storage）"><a href="#Asec（android-secure-storage）" class="headerlink" title="Asec（android secure storage）"></a>Asec（android secure storage）</h3><p>它提供了一种能安全的安装到设备上的机制，它让用户没法将一台设备的应用拷贝到另一台设备上（也称为预先锁定）。asec的创建和管理都是由vold完成，<code>vold</code>根据<code>MountService</code>发来的指令，执行相关的操作。asec创建和mount都需要密钥，在asec容器被mount的时候，vold会使用内核中device mapper，用loop参数执行mount操作，并通过DM_TABLE_LOAD ioctl操作，把密钥传递给内核中的dm-crypt模块。</p><p>密钥本身会以明文的形式保存在<code>/data/misc/systemkeys/AppsOnSD.sks</code>文件中。如果设备被root，则这个加密也会失去其木来的目的。</p><p>asec和obb这两种加密都是用了device mapper和它的文件加密功能（dm-crypt）创建和访问数据。asce实际上可以被视为obb的升级版，从加密存储应用的扩展文件，升级到加密存储的整个应用。</p><h2 id="linux伪文件系统"><a href="#linux伪文件系统" class="headerlink" title="linux伪文件系统"></a>linux伪文件系统</h2><p>伪文件系统所包含的文件都不会被存储在物理存储设备中，它们是直接由内核中的回调函数维护的。访问一个伪文件或目录时，某个对应的内核级处理函数就会被调用。因此这些伪文件的大小是没有意义的。</p><p>大多数伪文件都是以只读权限创建的，这些文件向用户态程序提供一种使之能够查看一些内核态中原本是不可访问的变量和结构体。少部分伪文件则是可写的，这些文件能够向用户态程序提供一种实时对内核中的数据施加影响的方法，就像注册表配置一样，且不用重启，但这些配置会因为系统的重启而丢失，在android系统中的init.rc脚本的重要功能就是保存这些配置。</p><table><thead><tr><th>FS</th><th></th><th>对应目录</th></tr></thead><tbody><tr><td>cgroupfs</td><td>androdi中只用来CPU计时和线程调度</td><td>-</td></tr><tr><td>debugfs</td><td>用于输出内核级别的调试信息，<code>mount -t debugfs none /sys/kernel/debug</code></td><td><code>/d</code></td></tr><tr><td>functionfs</td><td>由内核提供一个通用的文件系统，让驱动能够通过用户态的形式进行配置</td><td><code>/dev/usb-ffs/adb</code></td></tr><tr><td>procfs</td><td>提供一个机遇目录的观察系统中运行进程的方式</td><td><code>/proc</code></td></tr><tr><td>pstore</td><td>抓取内核崩溃的数据</td><td><code>/sys/fs/pstore</code></td></tr><tr><td>selinuxfs</td><td>存储了与安全策略相关的文件</td><td><code>/sys/fs/selinux</code></td></tr><tr><td>sysfs</td><td>linux 2.6以后作为补充而引入，比/proc更井井有条</td><td><code>/sys</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 安卓架构大剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 文件系统 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android文件系统中存储的内容</title>
      <link href="/2019/07/21/android%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AE%B9/"/>
      <url>/2019/07/21/android%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本章描述了android的文件系统,以及root文件系统、/system分区、/data分区、/cache分区以及/vendor目录和SDk的细节。</p><h3 id="root文件系统"><a href="#root文件系统" class="headerlink" title="root文件系统"></a>root文件系统</h3><p>android的root文件系统（/）是mount自ramdisk.img(initramfs)的文件。<br>每次启动时fastboot从boot分区中把这个镜像加载到内存中，并将其提交到内核进行管理。除非进行刷机（flashed）否则root文件系统将不会被更改。root系统中包含以后/init和与其相关的配置文件以及可执行文件，具体细节在下表：</p><table><thead><tr><th>目录或文件</th><th>注释</th></tr></thead><tbody><tr><td>default.prop</td><td>编译时<code>/build/core/main.mk</code>中<code>ADDITIONAL_DEFAULT_PROPERTIES</code>变量的值，init根据它加载其他系统范围内的属性文件</td></tr><tr><td>file_contexts</td><td>记录SELinux中文件的context。用于限制非授权用户访问系统文件和目录</td></tr><tr><td>init</td><td>将会被内核以pid 1执行的二进制文件</td></tr><tr><td>init[…].rc</td><td><code>/init</code>的配置文件，主要是init.rc</td></tr><tr><td>property_contexts</td><td>记录SELinux中的系统属性的contexts</td></tr><tr><td>seapp_contexts</td><td>记录SELinux中的应用的context，限制应用的操作域</td></tr><tr><td>sepolicy</td><td>SELinux策略设置编译后的结果</td></tr><tr><td>sbin/</td><td>该目录中有abd、healthd以及recovery等可执行文件，即使不mount /system也能够使用</td></tr><tr><td>verity_key</td><td>含有认证<code>/system</code>所需要的<code>DM_Verity RSA</code>密钥</td></tr></tbody></table><h3 id="system分区"><a href="#system分区" class="headerlink" title="/system分区"></a>/system分区</h3><p>该分区是存放谷歌或者其他厂商提供andorid组件的位置，该目录及其下所有文件都属于root:root，其权限为0755，但是该文件系统是以只读方式mount的；这样做的目的是提高文件系统的<strong>稳定性</strong>和<strong>安全性</strong>。理论上对于绝大多数设备来说，本分区下的所有目录以及文件都是一样的。实际上，一些厂商和运营商都会向<code>/system</code>添加自己的内容（android专门为厂商设计了<code>/vendor</code>目录来放置相关内容），具体细节在下表：</p><table><thead><tr><th>目录</th><th>注释</th></tr></thead><tbody><tr><td>app</td><td>存放系统应用，有谷歌预绑定的app，也有厂商提供的app</td></tr><tr><td>bin</td><td>存放二进制可执行文件，有守护进程的，也有一些命令行shell使用的</td></tr><tr><td>build.prop</td><td>在编译时生成的属性文件，<code>/init</code>根据它在启动过程中去加载其他的属性文件</td></tr><tr><td>etc</td><td>存储了各种配置文件，它是<code>/etc</code>的符号链接</td></tr><tr><td>fonts</td><td>字体文件</td></tr><tr><td>framework</td><td>存放android的框架，各个framework都会存放在各自的jar文件中，每个framework的dex文件经过优化后，会被存放在与jar文件同名的odex文件中</td></tr><tr><td>lib</td><td>存放运行时的库文件</td></tr><tr><td>lost+found</td><td>在<code>/system</code>进行fsck操作时生成的目录，系统如果崩溃，该目录可能会含有不知道自己上一级目录是谁的inode</td></tr><tr><td>media</td><td>以ogg形式存放的各种音频、以及在系统启动时播放的动画</td></tr><tr><td>priv-app</td><td>该目录存放了特权应用</td></tr><tr><td>usr</td><td>支持文件，比如unicode的映射文件、设备和键盘的键盘布局文件</td></tr><tr><td>vendor</td><td>用于存放厂商提供的文件，实际上厂商都不会放这里</td></tr><tr><td>xbin</td><td>存放用途特殊的，正常操作过程中不需要的二进制可执行文件。在模拟器中，这个目录都是存放来自asop的<code>/system/extras</code>的各种工具。各种提取su权限的root程序也放在这里</td></tr></tbody></table><h4 id="system-bin"><a href="#system-bin" class="headerlink" title="/system/bin"></a>/system/bin</h4><p>本目录放置andorid使用的各种可执行文件（包含调试工具）。具体可以分为5类：</p><ul><li><p>用来提供服务的可执行文件，这类二进制文件都是在系统运行过程中有<code>/init</code>来进行调用的，他们调用的路径保存在<code>/init</code>使用的rc文件中。</p><table><thead><tr><th>可执行文件</th><th>功能</th></tr></thead><tbody><tr><td>aoo_process</td><td>用户app的宿主进程，Zygote都是这个可执行文件的实例，它由Dalvik VM/ART初始化</td></tr><tr><td>applypatch[_static]</td><td>在OTA升级过程中使用–根据脚本来应用补丁</td></tr><tr><td>bootanimation</td><td>在图形界面子系统（<code>surfacefliger</code>）加载时，播放的启动动画</td></tr><tr><td>clatd</td><td>ipv4转ipv6的转换器</td></tr><tr><td>dalvikvm</td><td>用于启动dalvik虚拟机的实例</td></tr><tr><td>debuggerd</td><td>在系统崩溃时产生tombstone，也可以和一个远程gdb相连接</td></tr><tr><td>drmserver</td><td>DRM模块的宿主进程</td></tr><tr><td>dnsmasq</td><td>伪dns服务，在设备提供热点服务时，提供dns代理服务</td></tr><tr><td>hostpad</td><td>wifi热点守护进程</td></tr><tr><td>keystore</td><td>android的密钥存储和管理服务</td></tr><tr><td>linker</td><td>android运行时的链接器</td></tr><tr><td>mdnsd</td><td>组播dns的守护进程，用来使相邻的设备能够通过和wifi直连的方式相互发现和通信</td></tr><tr><td>mediaserver</td><td>音视频录制以及播放</td></tr><tr><td>mtpd</td><td>用来支持ppp/l2tp</td></tr><tr><td>netd</td><td>用来管理网卡以及防火墙</td></tr><tr><td>pppd</td><td>点对点协议守护进程，vpn需要使用</td></tr><tr><td>racoon</td><td>提供对vpn的支持</td></tr><tr><td>rlid</td><td>无线界面层守护进程</td></tr><tr><td>sdcard</td><td>sd卡守护进程，实现了sd卡文件系统，通过fuse模拟多用户权限设置</td></tr><tr><td>sensorservice</td><td>sensor hub，并发读取各种传感器</td></tr><tr><td>servicemanager</td><td>提供了服务的注册以及查找功能</td></tr><tr><td>surfaceflinger</td><td>画出图形界面的样子，并把他们加载到framebuffer中</td></tr><tr><td>vold</td><td>Volume守护进程，用来mount和unmount文件系统，也有文件系统的解密功能</td></tr><tr><td>uncrypt</td><td>解密文件系统，在recovery前使用</td></tr><tr><td>wpa_supplicant</td><td>无线访问适配层，提供wifi和wifi p2p的客户端支持</td></tr></tbody></table></li><li><p>调试工具，被归入这一类的事一些用于调试的原生二进制可执行文件（一般在模拟器中包含，厂商一般会在实机中删除）。</p></li><li><p>UNIX命令，unix相关的常用命令，和android特有的命令（getprop/setprop/watchprop），一般集成在<code>/system/bin/toolbox</code>中。</p></li><li><p>调用Dalvik的脚本（upcall script），这些脚本通过shell与Dalvik进行交互（主要是调试），这些脚本都是从<code>/sysytem/bin/app_process</code>派生未来，用它们在<code>/system/framework</code>目录中的同名框架，加载Dalvik类（zygote本身就是app_process的一个实例），使用时，脚本会把用户传给它的参数直接传递给Dalvik类。我们只需要看Dalvik脚本中的<strong>am</strong>就可以了解这些脚本的结构了。下表描述了<code>/system/bin</code>中封装了app_process的脚本。</p><table><thead><tr><th>脚本</th><th>用途</th></tr></thead><tbody><tr><td>am</td><td>与ActivityManager进行交互，启动activity发起的intent</td></tr><tr><td>bmgr</td><td>备份管理接口</td></tr><tr><td>bu</td><td>启动备份</td></tr><tr><td>content</td><td>与android content provider交互的接口</td></tr><tr><td>ime</td><td>控制输入法编辑器</td></tr><tr><td>input</td><td>与<code>InputManager</code>进行交互，注入输入事件</td></tr><tr><td>media</td><td>控制当前的媒体播放器</td></tr><tr><td>monkey</td><td>用随机生成的输入时间运行一个APK</td></tr><tr><td>pm</td><td>与包管理器进行交互，可以用来列出、安装、删除包以及列出权限</td></tr><tr><td>requestsync</td><td>同步账号</td></tr><tr><td>setting</td><td>获取、设置系统权限</td></tr><tr><td>svc</td><td>控制电源、数据、wifi和usb类服务</td></tr><tr><td>uiautomator</td><td>进行UI自动化测试，测试dump view之间的层次关系</td></tr><tr><td>wm</td><td>与窗口管理器进行交互、修改显示尺寸和分辨率等</td></tr></tbody></table></li><li><p>厂商定制的二进制脚本文件，这类文件完全可以由厂商提供，通常为提供服务或者调试的工具。当然这些文件也可以按照aosp的约定放到<code>/vendor</code>中,但这也不是强制的。</p></li></ul><h4 id="system-xbin"><a href="#system-xbin" class="headerlink" title="/system/xbin"></a>/system/xbin</h4><p>这个目录类似于unix中的<code>/sbin</code>，这里面含有管理员可能会觉得非常有用的二进制可执行文件，一般不提供给普通用户使用。这里命名为“x”而不是“s”是为了避免与android自身的<code>/sbin</code>（root文件系统中的一部分，含有系统操作时必须的二进制可执行文件）冲突。<br>这个目录中的可执行文件时从asop的<code>/system/extras</code>目录中编译得来的。这个目录会不会出现取决于厂商（有的厂商会吧这个目录删除）。下表中包含模拟器在该目录中包含的文件：</p><table><thead><tr><th>可执行文件</th><th>功能</th></tr></thead><tbody><tr><td>add-property-tag</td><td>向系统的.prop文件中添加属性</td></tr><tr><td>check-lost+found</td><td>在fsck操作完成之后，检查lost+found目录</td></tr><tr><td>cpueater</td><td>让cpu跑到100%的死循环</td></tr><tr><td>cpustats</td><td>显示cpu和处理器调节器的统计信息</td></tr><tr><td>daemonize</td><td>把一个可执行文件作为守护进程启动，并关闭stdin/stdout/stderr</td></tr><tr><td>dexdump</td><td>dex文件dump工具，也能dump文件头和字节码</td></tr><tr><td>directiotest</td><td>测试块设备io性能</td></tr><tr><td>kexecload</td><td>使用kexec系统调用，用一个新的内核重写内核镜像</td></tr><tr><td>ksminfo</td><td>显示ksm的使用信息</td></tr><tr><td>latencytop</td><td>以可读性更强的形式显示<code>/proc/sys/kernel/latencytop</code>中的数据</td></tr><tr><td>librank</td><td>给出各个共享内存区域所在各个进程中的使用情况</td></tr><tr><td>memtrack</td><td>跟踪进程的内存使用情况</td></tr><tr><td>micro_bench</td><td>内存基准测试工具</td></tr><tr><td>nc</td><td>netcat，分析TCP和UDP的工具</td></tr><tr><td>netperf</td><td>客户端网络性能分析工具</td></tr><tr><td>netserver</td><td>服务端网络性能分析工具</td></tr><tr><td>procmem</td><td>显示进程内存使用情况统计信息</td></tr><tr><td>procrank</td><td>和librank互补，它可以逐个进程给出共享内存使用信息</td></tr><tr><td>rawbu</td><td>在底层备份/恢复 <code>/data</code>中的数据</td></tr><tr><td>sane_schedstat</td><td>以刻度形式展示scheduler信息</td></tr><tr><td>showmap</td><td>显示进程内存的分配情况</td></tr><tr><td>showslab</td><td>显示内核slab分配器的信息</td></tr><tr><td>SQLite3</td><td>命令行工具</td></tr><tr><td>strace</td><td>系统调用trace工具</td></tr><tr><td>su</td><td>切换用户</td></tr><tr><td>taskstats</td><td>提供liunx的taskstats接口的详细使用统计信息</td></tr><tr><td>tcpdump</td><td>抓包工具</td></tr><tr><td>timeinfo</td><td>输出时间的相关信息</td></tr></tbody></table><p>在真实设备中，这些可执行文件作为调试工具特别有用，安装方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb pull /system/xbin #把模拟器中的文件复制到主机中</span><br><span class="line">#如果设备的/system文件可写</span><br><span class="line">adb push .. /system/xbin #把主机中的文件复制到设备中</span><br><span class="line">#除此之外，还有一些可执行文件的依赖库在/system/lib中可以找到</span><br></pre></td></tr></table></figure><h4 id="system-lib-64"><a href="#system-lib-64" class="headerlink" title="/system/lib[64]"></a>/system/lib[64]</h4><p>该目录中包含<code>/system/bin</code>和<code>/system/xbin</code>中可执行文件所使用的共享库。在大多数的设备中，<code>/system/lib</code>中包含有多个字目录，如下：</p><table><thead><tr><th>目录</th><th>介绍</th></tr></thead><tbody><tr><td>drm/</td><td>提供drm引擎。比如一些包含专利的so，libfwdlockengine.so</td></tr><tr><td>egl/</td><td>android版本的opengles</td></tr><tr><td>hw/</td><td>HAL模块</td></tr><tr><td>ssl/engines</td><td>含有libkeystore.so，该库使得OpenSSL能够使用android的Keystore机能</td></tr></tbody></table><p>在Intel设备中，本目录还包含有一个名为arm/的子目录，这个目录包含有arm架构编译的共享库的拷贝。这些库会被用在Intel二进制执行环境转换层（binary translation layer）Houdini上，用来为执行arm的可执行文件提供一个完整的运行时环境。</p><p>在android中几乎所有的二进制文件都是动态链接的。唯一例外的时<code>/sbin</code>目录中的二进制可执行文件。因为这些可执行文件会在<code>/system</code>被mount之前就会被用到。</p><h4 id="system-etc"><a href="#system-etc" class="headerlink" title="/system/etc"></a>/system/etc</h4><p>这个目录和unix类似，里面都存放这配置文件。<code>/etc</code>也是这个目录的符号链接，这样做的目的时为了让ASOP项目以外的项目也能找到配置文件（unix的配置文件目录就是<code>/etc</code>）。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>NOTICE.html.gz</td><td>法律文件</td></tr><tr><td>audio_effects.conf</td><td>被android的HAL层使用的文件</td></tr><tr><td>audio_polic.conf</td><td>被android的HAL层使用的文件</td></tr><tr><td>apns-conf.xml</td><td>被com.android.providers.telephony.TelephonyProvider使用</td></tr><tr><td>asound.conf</td><td>设备ALSA的配置文件</td></tr><tr><td>bluetooth</td><td>蓝牙配置文件</td></tr><tr><td>clatd.conf</td><td>CLATd,实现ipv4 over ipv6的配置文件</td></tr><tr><td>event-log-tags</td><td>各个android组件的日志log，被android.util.EventLog使用</td></tr><tr><td>fallback_fonts.xml</td><td>列出了在加载system_fonts.xml中没有指定的font-family时所能选用的fallback font。它会被android中的layoutlib的FontLoader所使用</td></tr><tr><td>gps.conf</td><td>gps配置文件</td></tr><tr><td>hosts</td><td>主机-IP表对应关系</td></tr><tr><td>media_codecs.xml</td><td>列出了StageFright所支持的所有codec</td></tr><tr><td>media_profiles.xml</td><td>列出了LibMedia所支持的所有profile</td></tr><tr><td>ppp/</td><td>存放启动/停止vpn和ppp连接活动的可执行文件</td></tr><tr><td>permissions</td><td>存放了多个xml文件，每个文件规定了一个内置文件应用的权限，它会被<code>PackageManager</code>使用</td></tr><tr><td>security</td><td>这个目录存有被各种安全证书</td></tr><tr><td>system_fonts.xml</td><td>列出字体样式，并把字体样式和<code>/system/fonts</code>中的各个TTF文件一一对应起来</td></tr><tr><td>wifi</td><td>WPA supplicant适配层的配置目录，用于控制wifi和wifi p2p的连接活动</td></tr></tbody></table><p>在不同的设备制造商手里，本目录中可能还有一些其他文件。</p><h3 id="data分区"><a href="#data分区" class="headerlink" title="/data分区"></a>/data分区</h3><p>这个分区使用来存放用户个人数据的，将用户的个人数据单独存放起来有如下的好处：</p><ul><li>降低<code>/data</code>和android系统的耦合。系统在升级或者恢复的时候仅会对<code>/system</code>目录进行操作（擦除或重写），而不会对<code>/data</code>中的用户数据有其他的影响。系统在恢复出厂设置时则仅会格式化/data分区，而不会对系统有其他的影响。</li><li>在用户需要时，<code>/data</code>能够被加密，而加密以及解密都会对系统运行造成延迟。而由于这种设计，<code>/system</code>中是没有敏感设备，加密用户的数据也就不会因加密而影响到系统，给系统带来相关的延迟。</li><li><code>/data</code>可以设置为不可执行，这样极大的加大了恶意软件的攻击难度。因为，恶意软件在设置为不可以执行后，就没有了可写又可执行的分区。因为DEX和OAT是运行在虚拟机里面的，所有这对Dalvik和ART app不会有任何影响。root后的设备是需要remount该分区的。</li></ul><p><code>/data</code>分区是以nosuid的权限mount的，这使得root设备更加复杂了一些，因为su不能放在/data中运行而只能放在 <code>/system</code>这样的只读分区中。如果系统在对<code>/system</code>进行hash校验的话，则root就更加不容易执行了。<br>下表列出了存储在<code>/data</code>分区中的内容：</p><table><thead><tr><th>目录</th><th>注释</th></tr></thead><tbody><tr><td>anr</td><td>dumpstate用来记录失去响应的应用的函数调用栈当前状态的地方</td></tr><tr><td>app</td><td>用户自己安装的应用</td></tr><tr><td>app-asec</td><td>存放asec的容器，每个asec加密的应用都对应一个asec容器</td></tr><tr><td>app-lib</td><td>应用的JNI库都可以在这里被找到</td></tr><tr><td>app-private</td><td>提供应用的私有存储空间，目前被asec替代</td></tr><tr><td>backup</td><td>供备份服务使用</td></tr><tr><td>bugreports</td><td>bugreport专用，用来存放bugreport生成的报告</td></tr><tr><td>davlvik-cache</td><td>用于存放优化过的系统应用和用户安装的应用的class.dex</td></tr><tr><td>data</td><td>各个已经安装的应用的目录，目录名为逆dns格式</td></tr><tr><td>dontpanic</td><td>未使用</td></tr><tr><td>drm</td><td>供android的数字版权管理器使用</td></tr><tr><td>local</td><td>供uid shell使用的一个临时目录，在adb中也可以使用</td></tr><tr><td>lost+found</td><td>对<code>/data</code>分区执行fsck操作时自动生成的目录</td></tr><tr><td>media</td><td>供sdcard服务吧sd卡mount到这个mount点上</td></tr><tr><td>mediadrm</td><td>供Media DRM服务使用</td></tr><tr><td>misc</td><td>各种其他文件的目录</td></tr><tr><td>nfc</td><td>存储NFC参数</td></tr><tr><td>property</td><td>存放持久性属性，文件名就是属性名</td></tr><tr><td>resource-cache</td><td>供<code>AssetManager</code>使用的资源缓存</td></tr><tr><td>security</td><td>一般为空</td></tr><tr><td>ssh</td><td>供那些ssh服务使用</td></tr><tr><td>system</td><td>存放了大量的系统配置文件</td></tr><tr><td>tombstone</td><td>存放由debuggerd生成的应用崩溃报告</td></tr><tr><td>user</td><td>与4.1版本开始引入。不同的用户会把各自的数据和应用安装在<code>/data/user/用户号</code>下的各个目录中，系统运行时，把<code>/data/data</code>下的对应目录做符号链接，使之指向<code>/data/user/用户号</code>下对应的目录。这样做可以使android系统支持多用户，<code>/data/data</code>会被直接指向<code>/data/user/0</code></td></tr></tbody></table><h4 id="data-data"><a href="#data-data" class="headerlink" title="/data/data"></a>/data/data</h4><p>这个目录是所有应用（系统应用、用户安装的应用）都存储其对应数据的地方。每一个应用都对应有一个目录，每个子目录权限为<code>0751</code>，而/data/data本身的权限为<code>0771，system system</code>,这意味着这个目录本身是可以执行的（cd命令），但却不能读出其包含的子目录。在应用中，每个应用对应的子目录也是这样的，能够执行却不能被非拥有者读取。</p><p>/data/data下各个目录的字目录都是其对应应用在整个文件系统中唯一能够执行写入的位置。</p><h4 id="data-misc"><a href="#data-misc" class="headerlink" title="/data/misc"></a>/data/misc</h4><p>和它的名字相反，这个目录有一些重要的文件。如下表：</p><table><thead><tr><th>目录</th><th>内容</th></tr></thead><tbody><tr><td>adb</td><td>存储可信的允许进行链接的电脑公钥</td></tr><tr><td>bluetooth</td><td>BlueZ[&lt;4.2]的配置文件</td></tr><tr><td>dhcp</td><td>存储实现dhcp的ctdent守护进程的PID文件</td></tr><tr><td>keychain</td><td>存放android内置证书pin码和黑名单</td></tr><tr><td>sensors</td><td>用于存储传感器调试数据</td></tr><tr><td>sms</td><td>存储短信codes数据库</td></tr><tr><td>systemkeys</td><td>用来存储asec容器的密钥</td></tr><tr><td>vpn</td><td>用来存储vpn状态配置文件</td></tr><tr><td>wifi</td><td>用于存储wifi子系统的配置文件和套接字</td></tr></tbody></table><h4 id="data-system"><a href="#data-system" class="headerlink" title="/data/system"></a>/data/system</h4><p>这个目录中含有对维护设备状态非常重要的文件。这个目录的访问权限也是被限制为<code>system system</code>，如果设备没有root，则无法看到该目录下的各个文件。下表中列出了相关文件：</p><table><thead><tr><th>目录</th><th>注释</th></tr></thead><tbody><tr><td>appops.xml</td><td>供控制应用权限的AppOps服务使用</td></tr><tr><td>batterystats.bin</td><td>供<code>BatteryStats</code>服务使用</td></tr><tr><td>called_pre_boots.dat</td><td>供<code>ActivityManager</code>记录每个Boot broadcast receiver</td></tr><tr><td>device_policies.xml</td><td><code>DevicePolicyManagerService</code>使用的配置文件</td></tr><tr><td>dropbox</td><td>供DropBox服务使用</td></tr><tr><td>entropy.dat</td><td>供<code>EntropyMixer</code>生成随机数使用</td></tr><tr><td>gesture.key</td><td>锁屏图案的hash</td></tr><tr><td>framework_atlas.config</td><td>供负责将预加载的bitmap组装成纹理贴图的<code>AssetAtlasService</code>使用</td></tr><tr><td>ifw/</td><td>Intent防火墙规则库</td></tr><tr><td>locksettings.db</td><td>锁屏设置，记录了设备的锁屏策略</td></tr><tr><td>netpolicy.xml</td><td>供<code>NetworkPolicyManagerService</code>使用的配置文件</td></tr><tr><td>netstats/</td><td>用来记录<code>NetworkStatsService</code>按device、uid或xt得到的网络传输数据统计的目录</td></tr><tr><td>packages.list</td><td><code>PackageManager</code>列出的所有安装在系统中的包</td></tr><tr><td>packages.xml</td><td><code>PackageManager</code>列出的所有已安装包的元数据</td></tr><tr><td>password.key</td><td>锁屏PIN码/口令的hash</td></tr><tr><td>procstats/</td><td>供<code>ProcessStats</code>服务存储文件的目录</td></tr><tr><td>registered_services/</td><td>供<code>android.content.pm.RegisteredServicesCache</code>使用的目录</td></tr><tr><td>usagestats/</td><td>供<code>UsageStats</code>服务存储文件，特别是usage-history.xml文件的目录</td></tr><tr><td>users/</td><td>android的多用户支持</td></tr></tbody></table><h3 id="cache分区"><a href="#cache分区" class="headerlink" title="/cache分区"></a>/cache分区</h3><p>android在系统升级的过程中使用本分区。系统的升级包会被下载到这里。设备在<code>recovery/</code>升级模式下启动时，会用到这个分区。<br>recovery这个可执行文件和系统在启动到recovery模式时，也会用到这个分区来交换信息。</p><h3 id="vendor分区"><a href="#vendor分区" class="headerlink" title="/vendor分区"></a>/vendor分区</h3><p>本分区是用来存储厂商对android系统的修改。这样做是避免在系统更新时厂商的修改也被抹除。一些专门的组件会在添加<code>/system</code>目录之前，回先去检查<code>/vendor</code>目录，具体会去检查哪些路径。</p><p>由于这个目录交由厂商处理，所以这些目录存储的内容在不同的设备上存在很大的区别。如/vendor/app目录是提供给厂商进行放置预装的应用，但实际上基本上没有人去用。</p><h3 id="sd卡"><a href="#sd卡" class="headerlink" title="sd卡"></a>sd卡</h3><p>大多数的sd卡都是exfat或者fat32文件系统，这两种系统都不支持权限管理。为了能实现权限管理、多用户配置，android通过FUSE（<code>file user</code>，用户态下的文件系统）模拟sd卡的方式来解决这个问题.FUSE使我们在用户态进程中实现文件系统。FUSE会在内核中安装一个用于支持通用文件系统的小模块，同过这个模块和VFS对接实现基本的注册文件系统功能，而真正的文件系统是在一个用户态进程（<code>/system/bin/sdcard</code>）中实现。在新版的android中，sd卡的mount点在<code>/storage/ext_sd</code>中，对于没有sd的设备，这个mount点通常会指向/data分区中的目录（<code>/data/media/0</code>）。</p><p>上面提到的一些目录都已经在<code>android.os.Environment</code>类中被定义为了常量。</p><p>android还提供了模拟sd卡文件系统，无论有没有sd卡都可以使用。通过mount命令，可以观察到sd卡文件系统。</p>]]></content>
      
      
      <categories>
          
          <category> 安卓架构大剖析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 文件系统 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARTS Week 2</title>
      <link href="/2019/07/17/ARTS-2/"/>
      <url>/2019/07/17/ARTS-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h1><a id="more"></a><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><blockquote><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        first = ListNode(<span class="number">0</span>)</span><br><span class="line">        curr = first</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">None</span>) <span class="keyword">or</span> (l2 != <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">if</span> l1 == <span class="literal">None</span>:</span><br><span class="line">                x = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2 == <span class="literal">None</span>:</span><br><span class="line">                y = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            sum = x + y + pre</span><br><span class="line">            mod = sum % <span class="number">10</span></span><br><span class="line">            pre = sum // <span class="number">10</span></span><br><span class="line">            curr.next = ListNode(mod)</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">if</span> pre == <span class="number">1</span>:</span><br><span class="line">            curr.next=ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> first.next</span><br></pre></td></tr></table></figure><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="http://newandroidbook.com/tools/imgtool.html" target="_blank" rel="noopener">imgtool</a></p><p>imgtool工具是包含在《最强Android书：架构大剖析》第三章<code>android启动备份和重置</code>中的工具套件，imgtool能够解析以及提取很多image。这套工具对于研究android的系统镜像提供了很大的帮助。imgtool工具套件提供了Mac OS X和linux的二进制可执行文件和源码。<br>这套工具可以在你刷机之前，检视这些image，避免被image中恶意软件所害。</p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><a href="https://wiki.jikexueyuan.com/project/shell-learning/sed-search-and-replace.html" target="_blank" rel="noopener">shell 学习第十天—sed 查找与替换</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 用 shell 命令将 test.log 文件中第 3-5 行的第 2 个“filter”替换成“haha”</span><br><span class="line">sed -i '3,5s/filter/haha/2' test.log</span><br></pre></td></tr></table></figure><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p><a href="https://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">SED 简明教程</a><br>sed有着很的处理的文本的能力，它能够通过强大的正则表达式来对文件进行批量的替换，省去了很多的机械作业。</p>]]></content>
      
      
      <categories>
          
          <category> ARTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARTS是什么</title>
      <link href="/2019/07/16/ARTS%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2019/07/16/ARTS%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>主要是为了编程训练和学习。每周至少做一个 leetcode 的算法题（先从Easy开始，然后再Medium，最后才Hard）。进行编程训练，如果不训练你看再多的算法书，你依然不会做算法题，看完书后，你需要训练。关于做Leetcode的的优势，你可以看一下我在coolshell上的文章：<a href="https://coolshell.cn/articles/12052.html" target="_blank" rel="noopener">LEETCODE 编程训练</a>。</p><a id="more"></a><h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>主要是为了学习英文，如果你的英文不行，你基本上无缘技术高手。所以，需要你阅读并点评至少一篇英文技术文章，我个人最喜欢去的地方是<a href="http://Medium.com" target="_blank" rel="noopener">Medium</a>以及各个公司的技术blog，如Netflix的。</p><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><p>主要是为了总结和归纳你在是常工作中所遇到的知识点。学习至少一个技术技巧。你在工作中遇到的问题，踩过的坑，学习的点滴知识。</p><h1 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h1><p>主要是为了建立你的影响力，能够输出价值观。分享一篇有观点和思考的技术文章。</p><p>引用：</p><blockquote><p><a href="https://time.geekbang.org/column/article/85839" target="_blank" rel="noopener">左耳听风 | ARTS 打卡召集令</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ARTS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
